"""
Vulnerability Management Service

Provides vulnerability tracking, scanning, and remediation management.
EPIC-021: Security Hardening
"""

from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
from uuid import UUID

from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func

from modules.security.models import (
    Vulnerability,
    SecurityScan,
    VulnerabilitySeverity,
    VulnerabilityStatus,
    ScanType,
)


# SLA definitions by severity (in hours)
SLA_BY_SEVERITY = {
    VulnerabilitySeverity.CRITICAL: 24,      # 1 day
    VulnerabilitySeverity.HIGH: 72,          # 3 days
    VulnerabilitySeverity.MEDIUM: 336,       # 14 days
    VulnerabilitySeverity.LOW: 720,          # 30 days
    VulnerabilitySeverity.NONE: None,        # No SLA
}


class VulnerabilityService:
    """Vulnerability Management Service"""

    def __init__(self, db: Session):
        self.db = db

    # =========================================================================
    # Vulnerability Management
    # =========================================================================

    def create_vulnerability(
        self,
        title: str,
        severity: VulnerabilitySeverity,
        scan_type: ScanType,
        scanner: str,
        component_type: str,
        component_name: str,
        tenant_id: Optional[UUID] = None,
        cve_id: Optional[str] = None,
        description: Optional[str] = None,
        cvss_score: Optional[float] = None,
        cvss_vector: Optional[str] = None,
        scan_id: Optional[str] = None,
        component_version: Optional[str] = None,
        affected_file: Optional[str] = None,
        affected_line: Optional[int] = None,
        fix_available: bool = False,
        fixed_version: Optional[str] = None,
        remediation_guidance: Optional[str] = None,
    ) -> Vulnerability:
        """Create a vulnerability record"""

        # Check for duplicate
        existing = None
        if cve_id:
            existing = self.db.query(Vulnerability).filter(
                Vulnerability.cve_id == cve_id,
                Vulnerability.component_name == component_name,
                Vulnerability.status != VulnerabilityStatus.REMEDIATED,
            ).first()

        if existing:
            # Update existing vulnerability
            existing.scan_id = scan_id
            existing.discovered_at = datetime.utcnow()
            self.db.commit()
            return existing

        # Calculate SLA due date
        sla_hours = SLA_BY_SEVERITY.get(severity)
        sla_due_date = None
        if sla_hours:
            sla_due_date = datetime.utcnow() + timedelta(hours=sla_hours)

        vuln = Vulnerability(
            tenant_id=tenant_id,
            cve_id=cve_id,
            title=title,
            description=description,
            severity=severity,
            cvss_score=cvss_score,
            cvss_vector=cvss_vector,
            scan_type=scan_type,
            scanner=scanner,
            scan_id=scan_id,
            component_type=component_type,
            component_name=component_name,
            component_version=component_version,
            affected_file=affected_file,
            affected_line=affected_line,
            status=VulnerabilityStatus.OPEN,
            fix_available=fix_available,
            fixed_version=fixed_version,
            remediation_guidance=remediation_guidance,
            sla_due_date=sla_due_date,
        )

        self.db.add(vuln)
        self.db.commit()
        self.db.refresh(vuln)

        return vuln

    def get_vulnerability(
        self,
        vuln_id: UUID,
    ) -> Optional[Vulnerability]:
        """Get vulnerability by ID"""

        return self.db.query(Vulnerability).filter(
            Vulnerability.id == vuln_id,
        ).first()

    def get_vulnerability_by_cve(
        self,
        cve_id: str,
    ) -> List[Vulnerability]:
        """Get vulnerabilities by CVE ID"""

        return self.db.query(Vulnerability).filter(
            Vulnerability.cve_id == cve_id,
        ).all()

    def list_vulnerabilities(
        self,
        tenant_id: Optional[UUID] = None,
        severity: Optional[VulnerabilitySeverity] = None,
        status: Optional[VulnerabilityStatus] = None,
        scan_type: Optional[ScanType] = None,
        component_name: Optional[str] = None,
        sla_breached_only: bool = False,
        limit: int = 100,
    ) -> List[Vulnerability]:
        """List vulnerabilities with filters"""

        query = self.db.query(Vulnerability)

        if tenant_id:
            query = query.filter(Vulnerability.tenant_id == tenant_id)
        if severity:
            query = query.filter(Vulnerability.severity == severity)
        if status:
            query = query.filter(Vulnerability.status == status)
        if scan_type:
            query = query.filter(Vulnerability.scan_type == scan_type)
        if component_name:
            query = query.filter(Vulnerability.component_name.ilike(f"%{component_name}%"))
        if sla_breached_only:
            query = query.filter(
                Vulnerability.sla_due_date < datetime.utcnow(),
                Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]),
            )

        return query.order_by(
            Vulnerability.severity.desc(),
            Vulnerability.sla_due_date.asc(),
        ).limit(limit).all()

    def update_vulnerability_status(
        self,
        vuln_id: UUID,
        status: VulnerabilityStatus,
        assigned_to: Optional[UUID] = None,
    ) -> Optional[Vulnerability]:
        """Update vulnerability status"""

        vuln = self.get_vulnerability(vuln_id)
        if not vuln:
            return None

        vuln.status = status

        if status == VulnerabilityStatus.REMEDIATED:
            vuln.remediated_at = datetime.utcnow()
        elif status == VulnerabilityStatus.ACCEPTED:
            vuln.remediated_at = datetime.utcnow()  # Track when risk was accepted

        if assigned_to:
            vuln.assigned_to = assigned_to

        self.db.commit()
        self.db.refresh(vuln)

        return vuln

    def verify_remediation(
        self,
        vuln_id: UUID,
    ) -> Optional[Vulnerability]:
        """Mark vulnerability as verified"""

        vuln = self.get_vulnerability(vuln_id)
        if not vuln:
            return None

        vuln.verified_at = datetime.utcnow()

        self.db.commit()
        self.db.refresh(vuln)

        return vuln

    def mark_false_positive(
        self,
        vuln_id: UUID,
        reason: Optional[str] = None,
    ) -> Optional[Vulnerability]:
        """Mark vulnerability as false positive"""

        vuln = self.get_vulnerability(vuln_id)
        if not vuln:
            return None

        vuln.status = VulnerabilityStatus.FALSE_POSITIVE
        vuln.remediated_at = datetime.utcnow()
        if reason:
            vuln.remediation_guidance = f"False positive: {reason}"

        self.db.commit()
        self.db.refresh(vuln)

        return vuln

    # =========================================================================
    # Security Scanning
    # =========================================================================

    def start_scan(
        self,
        scan_type: ScanType,
        scanner: str,
        target: str,
        tenant_id: Optional[UUID] = None,
        target_version: Optional[str] = None,
        scan_config: Optional[Dict] = None,
        triggered_by: str = "scheduled",
        triggered_by_user: Optional[UUID] = None,
    ) -> SecurityScan:
        """Start a security scan"""

        scan = SecurityScan(
            tenant_id=tenant_id,
            scan_type=scan_type,
            scanner=scanner,
            target=target,
            target_version=target_version,
            started_at=datetime.utcnow(),
            status="running",
            scan_config=scan_config,
            triggered_by=triggered_by,
            triggered_by_user=triggered_by_user,
        )

        self.db.add(scan)
        self.db.commit()
        self.db.refresh(scan)

        return scan

    def complete_scan(
        self,
        scan_id: UUID,
        total_findings: int,
        critical_count: int = 0,
        high_count: int = 0,
        medium_count: int = 0,
        low_count: int = 0,
        error_message: Optional[str] = None,
    ) -> Optional[SecurityScan]:
        """Complete a security scan"""

        scan = self.db.query(SecurityScan).filter(
            SecurityScan.id == scan_id,
        ).first()

        if not scan:
            return None

        scan.completed_at = datetime.utcnow()
        scan.duration_seconds = int((scan.completed_at - scan.started_at).total_seconds())
        scan.status = "completed" if not error_message else "failed"
        scan.error_message = error_message
        scan.total_findings = total_findings
        scan.critical_count = critical_count
        scan.high_count = high_count
        scan.medium_count = medium_count
        scan.low_count = low_count

        self.db.commit()
        self.db.refresh(scan)

        return scan

    def get_scan(
        self,
        scan_id: UUID,
    ) -> Optional[SecurityScan]:
        """Get scan by ID"""

        return self.db.query(SecurityScan).filter(
            SecurityScan.id == scan_id,
        ).first()

    def list_scans(
        self,
        tenant_id: Optional[UUID] = None,
        scan_type: Optional[ScanType] = None,
        status: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        limit: int = 50,
    ) -> List[SecurityScan]:
        """List security scans"""

        query = self.db.query(SecurityScan)

        if tenant_id:
            query = query.filter(SecurityScan.tenant_id == tenant_id)
        if scan_type:
            query = query.filter(SecurityScan.scan_type == scan_type)
        if status:
            query = query.filter(SecurityScan.status == status)
        if start_time:
            query = query.filter(SecurityScan.started_at >= start_time)
        if end_time:
            query = query.filter(SecurityScan.started_at <= end_time)

        return query.order_by(SecurityScan.started_at.desc()).limit(limit).all()

    # =========================================================================
    # Vulnerability Dashboard & Analytics
    # =========================================================================

    def get_vulnerability_dashboard(
        self,
        tenant_id: Optional[UUID] = None,
    ) -> Dict[str, Any]:
        """Get vulnerability dashboard metrics"""

        # Open vulnerabilities by severity
        open_by_severity = dict(
            self.db.query(
                Vulnerability.severity,
                func.count(Vulnerability.id),
            ).filter(
                Vulnerability.tenant_id == tenant_id if tenant_id else True,
                Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]),
            ).group_by(Vulnerability.severity).all()
        )

        # Total counts
        total_open = sum(open_by_severity.values())
        total_critical = open_by_severity.get(VulnerabilitySeverity.CRITICAL, 0)
        total_high = open_by_severity.get(VulnerabilitySeverity.HIGH, 0)

        # SLA breaches
        sla_breached = self.db.query(Vulnerability).filter(
            Vulnerability.tenant_id == tenant_id if tenant_id else True,
            Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]),
            Vulnerability.sla_due_date < datetime.utcnow(),
        ).count()

        # Vulnerabilities by component type
        by_component = dict(
            self.db.query(
                Vulnerability.component_type,
                func.count(Vulnerability.id),
            ).filter(
                Vulnerability.tenant_id == tenant_id if tenant_id else True,
                Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]),
            ).group_by(Vulnerability.component_type).all()
        )

        # Recent scans
        recent_scans = self.db.query(SecurityScan).filter(
            SecurityScan.tenant_id == tenant_id if tenant_id else True,
        ).order_by(SecurityScan.started_at.desc()).limit(5).all()

        # Remediation metrics (last 30 days)
        since = datetime.utcnow() - timedelta(days=30)

        remediated_count = self.db.query(Vulnerability).filter(
            Vulnerability.tenant_id == tenant_id if tenant_id else True,
            Vulnerability.status == VulnerabilityStatus.REMEDIATED,
            Vulnerability.remediated_at >= since,
        ).count()

        new_count = self.db.query(Vulnerability).filter(
            Vulnerability.tenant_id == tenant_id if tenant_id else True,
            Vulnerability.discovered_at >= since,
        ).count()

        # Mean time to remediate (MTTR)
        remediated_vulns = self.db.query(Vulnerability).filter(
            Vulnerability.tenant_id == tenant_id if tenant_id else True,
            Vulnerability.status == VulnerabilityStatus.REMEDIATED,
            Vulnerability.remediated_at != None,
            Vulnerability.discovered_at >= since,
        ).all()

        mttr_hours = 0
        if remediated_vulns:
            total_hours = sum(
                (v.remediated_at - v.discovered_at).total_seconds() / 3600
                for v in remediated_vulns
            )
            mttr_hours = total_hours / len(remediated_vulns)

        return {
            "summary": {
                "total_open": total_open,
                "critical": total_critical,
                "high": total_high,
                "sla_breached": sla_breached,
            },
            "by_severity": {
                k.value if k else "unknown": v
                for k, v in open_by_severity.items()
            },
            "by_component": by_component,
            "trends_30_days": {
                "new": new_count,
                "remediated": remediated_count,
                "net_change": new_count - remediated_count,
                "mttr_hours": round(mttr_hours, 2),
            },
            "recent_scans": [
                {
                    "id": str(s.id),
                    "type": s.scan_type.value,
                    "scanner": s.scanner,
                    "target": s.target,
                    "status": s.status,
                    "findings": s.total_findings or 0,
                    "started_at": s.started_at.isoformat(),
                }
                for s in recent_scans
            ],
        }

    def get_sla_compliance_report(
        self,
        tenant_id: Optional[UUID] = None,
        days: int = 30,
    ) -> Dict[str, Any]:
        """Get SLA compliance report"""

        since = datetime.utcnow() - timedelta(days=days)

        # Vulnerabilities by SLA status
        total_with_sla = self.db.query(Vulnerability).filter(
            Vulnerability.tenant_id == tenant_id if tenant_id else True,
            Vulnerability.sla_due_date != None,
            Vulnerability.discovered_at >= since,
        ).count()

        within_sla = self.db.query(Vulnerability).filter(
            Vulnerability.tenant_id == tenant_id if tenant_id else True,
            Vulnerability.sla_due_date != None,
            Vulnerability.discovered_at >= since,
            or_(
                Vulnerability.status == VulnerabilityStatus.REMEDIATED,
                Vulnerability.sla_due_date >= datetime.utcnow(),
            ),
        ).count()

        breached_sla = total_with_sla - within_sla

        # By severity
        compliance_by_severity = {}
        for severity in VulnerabilitySeverity:
            if severity == VulnerabilitySeverity.NONE:
                continue

            total = self.db.query(Vulnerability).filter(
                Vulnerability.tenant_id == tenant_id if tenant_id else True,
                Vulnerability.severity == severity,
                Vulnerability.sla_due_date != None,
                Vulnerability.discovered_at >= since,
            ).count()

            compliant = self.db.query(Vulnerability).filter(
                Vulnerability.tenant_id == tenant_id if tenant_id else True,
                Vulnerability.severity == severity,
                Vulnerability.sla_due_date != None,
                Vulnerability.discovered_at >= since,
                or_(
                    Vulnerability.status == VulnerabilityStatus.REMEDIATED,
                    Vulnerability.sla_due_date >= datetime.utcnow(),
                ),
            ).count()

            compliance_by_severity[severity.value] = {
                "total": total,
                "compliant": compliant,
                "compliance_rate": compliant / total if total > 0 else 1.0,
            }

        return {
            "period_days": days,
            "overall": {
                "total": total_with_sla,
                "within_sla": within_sla,
                "breached": breached_sla,
                "compliance_rate": within_sla / total_with_sla if total_with_sla > 0 else 1.0,
            },
            "by_severity": compliance_by_severity,
            "sla_definitions": {
                k.value: f"{v} hours" if v else "No SLA"
                for k, v in SLA_BY_SEVERITY.items()
            },
        }

    def get_top_vulnerable_components(
        self,
        tenant_id: Optional[UUID] = None,
        limit: int = 10,
    ) -> List[Dict[str, Any]]:
        """Get components with most vulnerabilities"""

        results = self.db.query(
            Vulnerability.component_name,
            Vulnerability.component_type,
            func.count(Vulnerability.id).label("total"),
            func.sum(
                func.cast(Vulnerability.severity == VulnerabilitySeverity.CRITICAL, Integer)
            ).label("critical"),
            func.sum(
                func.cast(Vulnerability.severity == VulnerabilitySeverity.HIGH, Integer)
            ).label("high"),
        ).filter(
            Vulnerability.tenant_id == tenant_id if tenant_id else True,
            Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]),
        ).group_by(
            Vulnerability.component_name,
            Vulnerability.component_type,
        ).order_by(
            func.count(Vulnerability.id).desc(),
        ).limit(limit).all()

        return [
            {
                "component_name": r[0],
                "component_type": r[1],
                "total_vulnerabilities": r[2],
                "critical_count": r[3] or 0,
                "high_count": r[4] or 0,
            }
            for r in results
        ]


# Import for type casting in queries
from sqlalchemy import Integer
